rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ========================================
    // Helper Functions
    // ========================================
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/Users/$(request.auth.token.email)).data;
    }
    
    function getUserRole() {
      return getUserData().role;
    }
    
    function getUserDepartment() {
      return getUserData().department;
    }
    
    function isDirector() {
      return isSignedIn() && (getUserRole() == 'director' || getUserRole() == 'Director');
    }
    
    function isManager() {
      return isSignedIn() && (getUserRole() == 'manager' || getUserRole() == 'Manager');
    }
    
    function isHR() {
      return isSignedIn() && (getUserRole() == 'hr' || getUserRole() == 'HR');
    }
    
    function isStaff() {
      return isSignedIn() && (getUserRole() == 'staff' || getUserRole() == 'Staff');
    }
    
    function isProjectMember(projectData) {
      return request.auth.token.email in projectData.members ||
             request.auth.token.email == projectData.createdBy;
    }
    
    function isOwner(resourceData) {
      return request.auth.token.email == resourceData.createdBy;
    }
    
    // ========================================
    // Users Collection
    // ========================================
    match /Users/{userId} {
      // Users can read their own profile
      allow read: if isSignedIn() && request.auth.token.email == userId;
      
      // Directors, Managers (by dept), and HR can read user profiles
      allow read: if isDirector() || isHR() || (isManager() && getUserDepartment() == resource.data.department);

      // Anyone can create their own account (self-registration)
      allow create: if request.auth.token.email == userId;
      
      // Users can update their own profile (but not change their role/dept)
      allow update: if isSignedIn() &&
                request.auth.token.email == userId &&
                request.resource.data.keys().hasAll(['role', 'department']) &&
                resource.data.keys().hasAll(['role', 'department']) &&
                request.resource.data.role == resource.data.role &&
                request.resource.data.department == resource.data.department;
      // Only directors can delete users
      allow delete: if isDirector();

      // --- THIS IS THE FIX ---
      // Add rules for the 'notifications' subcollection INSIDE the user document match.
      // This allows a user to read/write notifications in their OWN subcollection.
      match /notifications/{notificationId} {
        // A user can read their own notifications
        allow read: if isSignedIn() && request.auth.token.email == userId;
        
        // The application (running as the user) can create new notifications
        allow create: if isSignedIn() && request.auth.token.email == userId;
        
        // The application (running as the user) can update 'isRead' status
        allow update: if isSignedIn() && request.auth.token.email == userId;
      }
      // --- END OF FIX ---
    }
    
    // ========================================
    // Projects Collection
    // ========================================
    match /projects/{projectId} {
      // (Your existing project rules are correct)
      allow read, write: if isDirector();
      allow read: if isManager() && 
                    (getUserDepartment() == resource.data.department || isProjectMember(resource.data));
      allow read: if isHR();
      allow read: if isStaff() && isProjectMember(resource.data);
      allow create: if (isDirector() || isManager() || isStaff()) && !isHR();
      allow update: if isProjectMember(resource.data) && !isHR();
      allow delete: if isOwner(resource.data);
    }
    
    // ========================================
    // Tasks Collection
    // ========================================
    match /tasks/{taskId} {
      // (Your existing task rules are correct)
      allow read, write, delete: if isDirector();
      
      function hasProject(taskData) { return taskData.projectId != null && taskData.projectId != ''; }
      function getProject(taskData) {
        return hasProject(taskData) ? 
          get(/databases/$(database)/documents/projects/$(taskData.projectId)).data : 
          null;
      }
      function isTaskMember(taskData) {
        return request.auth.token.email == taskData.taskOwner ||
               request.auth.token.email == taskData.assignedTo ||
               (taskData.collaborators != null && request.auth.token.email in taskData.collaborators) ||
               request.auth.token.email == taskData.createdBy;
      }
      function canAccessProject(taskData) {
        let projectData = getProject(taskData);
        return projectData == null || 
               request.auth.token.email in projectData.members ||
               request.auth.token.email == projectData.createdBy ||
               (isManager() && getUserDepartment() == projectData.department);
      }
      
      allow read: if isManager() && (isTaskMember(resource.data) || canAccessProject(resource.data));
      allow read: if isHR();
      allow read: if isStaff() && isTaskMember(resource.data);
      
      allow create: if isSignedIn() && !isHR() &&
                    (!hasProject(request.resource.data) ||
                     request.auth.token.email in get(/databases/$(database)/documents/projects/$(request.resource.data.projectId)).data.members);
      
      allow update: if isTaskMember(resource.data) && !isHR() &&
                    (request.resource.data.dueDate == resource.data.dueDate ||
                     request.auth.token.email == resource.data.createdBy ||
                     request.auth.token.email == resource.data.taskOwner);
      
      allow update: if isTaskMember(resource.data) && 
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isDeleted', 'deletedAt', 'deletedBy']);
      
      allow delete: if isTaskMember(resource.data);
    }
    
    // ========================================
    // Other Collections
    // ========================================
    
    // --- THIS IS THE FIX ---
    // The incorrect root-level 'notifications' rule has been removed from here.
    // --- END OF FIX ---
    
    match /passwordResets/{resetId} {
      allow read, write: if true;
    }
    
    match /loginAttempts/{attemptId} {
      allow read, write: if true;
    }
    
    match /reminders/{reminderId} {
      allow read: if isSignedIn() && 
                    resource.data.userId == request.auth.token.email;
      allow write: if isSignedIn();
    }

    // ========================================
    // Categories Collection
    // ========================================
    match /categories/{categoryId} {
      // Anyone signed in can read categories
      allow read: if isSignedIn();
      // Directors, managers, and staff can create/update/delete categories
      allow write: if isDirector() || isManager() || isStaff();
    }

    // ========================================
    // Departments Collection
    // ========================================
    match /departments/{departmentId} {
      // Anyone signed in can read departments
      allow read: if isSignedIn();
      // Only directors and HR can create/update/delete departments
      allow write: if isDirector() || isHR();
    }
  }
}
